import React, { useEffect, useState } from "react";
import {
  View,
  Text,
  StyleSheet,
  ScrollView,
  TouchableOpacity,
  Animated,
  Dimensions,
} from "react-native";
import { CameraView, Camera } from "expo-camera";
import { useScanStore } from "../../hooks/useScanStore";
import { theme } from "../../constants/theme";
import { MaterialIcons } from "@expo/vector-icons";

const { width: SCREEN_W, height: SCREEN_H } = Dimensions.get("window");

type BarcodeScanningResult = {
  data: string;
  bounds?: {
    origin: { x: number; y: number };
    size: { width: number; height: number };
  };
  cornerPoints?: { x: number; y: number }[];
  type?: string;
};

interface BarcodeBox {
  id: string;
  data: string;
  color: string;
  bounds: {
    origin: { x: number; y: number };
    size: { width: number; height: number };
  };
  opacity: Animated.Value;
}

export default function ScannerScreen() {
  const [hasPermission, setHasPermission] = useState<boolean | null>(null);
  const [barcodeBoxes, setBarcodeBoxes] = useState<BarcodeBox[]>([]);
  const [camSize, setCamSize] = useState<{ w: number; h: number }>({
    w: 0,
    h: 0,
  });
  const [scannedCodes, setScannedCodes] = useState<Set<string>>(new Set());
  const [permanentMarkers, setPermanentMarkers] = useState<Map<string, BarcodeBox>>(new Map());

  // Viewfinder ratio (centered rectangle). Tweak ratios to your liking.
  const VF_WIDTH_RATIO = 0.75; // 75% of camera width
  const VF_HEIGHT_RATIO = 0.55; // 55% of camera height
  const { products, addScan, loadData, clearAll } = useScanStore();

  useEffect(() => {
    (async () => {
      const { status } = await Camera.requestCameraPermissionsAsync();
      setHasPermission(status === "granted");
      await loadData();
    })();
  }, []);

  // 1) Estimate source preview dimensions from this frame's barcodes
  const estimateSourceSize = (barcodes: BarcodeScanningResult[]) => {
  let maxX = 0, maxY = 0;
  for (const b of barcodes) {
    if (b.cornerPoints?.length) {
      for (const p of b.cornerPoints) { maxX = Math.max(maxX, p.x); maxY = Math.max(maxY, p.y); }
    } else if (b.bounds) {
      const { origin, size } = b.bounds;
      const normalized = origin.x <= 1.2 && origin.y <= 1.2 && size.width <= 1.2 && size.height <= 1.2;
      if (!normalized) { maxX = Math.max(maxX, origin.x + size.width); maxY = Math.max(maxY, origin.y + size.height); }
    }
  }
  if (maxX < 1 || maxY < 1) return { srcW: 720, srcH: 1280 };
  return { srcW: maxX, srcH: maxY };
};

  // 2) Map a rect from source preview space → camera view space (cover fit)
  const mapRectCover = (
    rect: { left: number; top: number; width: number; height: number },
    W: number,
    H: number,
    srcW: number,
    srcH: number
  ) => {
    const scale = Math.max(W / srcW, H / srcH);
    const dispW = srcW * scale;
    const dispH = srcH * scale;
    const offsetX = (W - dispW) / 2;
    const offsetY = (H - dispH) / 2;

    return {
      left: offsetX + rect.left * scale,
      top: offsetY + rect.top * scale,
      width: rect.width * scale,
      height: rect.height * scale,
    };
  };

  // 3) Build a rect (in source space) from a barcode (cornerPoints preferred)
  const rectFromBarcodeSource = (b: BarcodeScanningResult) => {
    if (b.cornerPoints?.length) {
      const xs = b.cornerPoints.map((p) => p.x);
      const ys = b.cornerPoints.map((p) => p.y);
      const left = Math.min(...xs);
      const top = Math.min(...ys);
      const right = Math.max(...xs);
      const bottom = Math.max(...ys);
      return {
        left,
        top,
        width: right - left,
        height: bottom - top,
        normalized: false,
      };
    }
    if (b.bounds) {
      const { origin, size } = b.bounds;
      const looksNormalized =
        origin.x <= 1.2 &&
        origin.y <= 1.2 &&
        size.width <= 1.2 &&
        size.height <= 1.2;
      if (looksNormalized) {
        return {
          left: origin.x,
          top: origin.y,
          width: size.width,
          height: size.height,
          normalized: true,
        };
      }
      return {
        left: origin.x,
        top: origin.y,
        width: size.width,
        height: size.height,
        normalized: false,
      };
    }
    // last resort fallback
    return { left: 0.35, top: 0.35, width: 0.3, height: 0.2, normalized: true };
  };

  // Heuristic: determine whether bounds are normalized (0..1) or pixels
  const boundsToPixels = (
    bounds: {
      origin: { x: number; y: number };
      size: { width: number; height: number };
    },
    W: number,
    H: number
  ) => {
    const { origin, size } = bounds;
    const normalized =
      origin.x <= 1.2 &&
      origin.y <= 1.2 &&
      size.width <= 1.2 &&
      size.height <= 1.2;

    if (normalized) {
      return {
        left: origin.x * W,
        top: origin.y * H,
        width: size.width * W,
        height: size.height * H,
      };
    }
    return {
      left: origin.x,
      top: origin.y,
      width: size.width,
      height: size.height,
    };
  };

  const rectCenter = (rect: {
    left: number;
    top: number;
    width: number;
    height: number;
  }) => ({
    cx: rect.left + rect.width / 2,
    cy: rect.top + rect.height / 2,
  });

  const pointInRect = (
    x: number,
    y: number,
    rect: { left: number; top: number; width: number; height: number }
  ) =>
    x >= rect.left &&
    x <= rect.left + rect.width &&
    y >= rect.top &&
    y <= rect.top + rect.height;

  // Main handler for detected barcodes (we’ll filter to viewfinder and cap to 4)
  const handleBarcodes = async (event: {
    barcodes: BarcodeScanningResult[];
  }) => {
    const { barcodes } = event;
    if (!barcodes?.length || camSize.w === 0 || camSize.h === 0) return;

    const W = camSize.w;
    const H = camSize.h;

    // Compute viewfinder rect in pixels (centered)
    const vfWidth = W * VF_WIDTH_RATIO;
    const vfHeight = H * VF_HEIGHT_RATIO;
    const vfLeft = (W - vfWidth) / 2;
    const vfTop = (H - vfHeight) / 2;
    const viewfinderRect = {
      left: vfLeft,
      top: vfTop,
      width: vfWidth,
      height: vfHeight,
    };

    // Map incoming barcodes to pixel rectangles and filter to those whose center is inside viewfinder
    const candidates = barcodes
      .filter((b) => b.data)
      .map((b) => {
        // prefer bounds; if missing, try cornerPoints; else fallback (center)
        let bounds = b.bounds;
        if (!bounds && b.cornerPoints && b.cornerPoints.length >= 2) {
          // cornerPoints seem to have x/y swapped - swap them back
          const xs = b.cornerPoints.map((p) => p.y); // Use y as x coordinate
          const ys = b.cornerPoints.map((p) => p.x); // Use x as y coordinate
          const minX = Math.min(...xs);
          const minY = Math.min(...ys);
          const maxX = Math.max(...xs);
          const maxY = Math.max(...ys);
          // cornerPoints are in pixel coordinates
          bounds = {
            origin: { x: minX, y: minY },
            size: { width: maxX - minX, height: maxY - minY },
          };
        }
        if (!bounds) {
          // very rare fallback
          bounds = {
            origin: { x: 0.35, y: 0.35 },
            size: { width: 0.3, height: 0.2 },
          };
        }
        const px = boundsToPixels(bounds, W, H);
        console.log(
          "[SCAN:RAW]",
          JSON.stringify(
            {
              data: b.data,
              type: b.type,
              bounds,
              cornerPoints: b.cornerPoints?.slice(0, 4),
              px,
            },
            null,
            2
          )
        );

        return { data: b.data!, px, bounds };
      })
      .filter((c) => {
        const { cx, cy } = rectCenter(c.px);
        return pointInRect(cx, cy, viewfinderRect);
      })
      // sort by area (largest first) so we pick the most confident ones
      .sort((a, b) => b.px.width * b.px.height - a.px.width * a.px.height)
      // cap to 4
      .slice(0, 4);

    if (!candidates.length) return;

    for (const c of candidates) {
      const data = c.data;

      // Check if already scanned - skip duplicate
      if (scannedCodes.has(data)) {
        continue;
      }

      const productId = data.split("-")[0];
      const existing = products[productId];
      const duplicate = existing?.codes.includes(data);

      let scanSuccess = false;
      const pxNow = boundsToPixels(c.bounds, W, H);

      // Viewfinder içinde mi?
      const cx = pxNow.left + pxNow.width / 2;
      const cy = pxNow.top + pxNow.height / 2;
      const insideVF =
        cx >= vfLeft &&
        cx <= vfLeft + vfWidth &&
        cy >= vfTop &&
        cy <= vfTop + vfHeight;

      // Konsol log: ürün ve kutu ölçüleri
      console.log("[SCAN:BOX]", {
        productId,
        code: data,
        rect: {
          left: Math.round(pxNow.left),
          top: Math.round(pxNow.top),
          width: Math.round(pxNow.width),
          height: Math.round(pxNow.height),
        },
        center: { cx: Math.round(cx), cy: Math.round(cy) },
        insideViewfinder: insideVF,
      });

      if (!duplicate) {
        try {
          await addScan(data, productId);
          scanSuccess = true;
          setScannedCodes((prev) => new Set([...prev, data]));
        } catch (error) {
          console.error("Scan failed:", error);
        }
      } else {
        continue; // Skip if already in products
      }

      // Create visual feedback box
      const id = `${data}-${Date.now()}`;
      const opacity = new Animated.Value(1);

      const newBox: BarcodeBox = {
        id,
        data,
        color: scanSuccess ? theme.colors.accent : theme.colors.danger,
        bounds: c.bounds,
        opacity,
      };

      setBarcodeBoxes((prev) => {
        const newBoxes = [...prev, newBox].slice(-4);
        console.log("[BOX STATE UPDATE] Total boxes:", newBoxes.length, "New box ID:", id);
        return newBoxes;
      });

      if (!scanSuccess) {
        // Log red box creation
        console.log("[TEMPORARY BOX] Red box created:", {
          code: data,
          productId,
          bounds: c.bounds,
          pixelPosition: {
            left: Math.round(pxNow.left),
            top: Math.round(pxNow.top),
            width: Math.round(pxNow.width),
            height: Math.round(pxNow.height),
          },
          center: {
            x: Math.round(cx),
            y: Math.round(cy),
          },
          duration: "0.5s",
          reason: "Scan failed",
        });

        // Red box for failed scan - fade quickly
        Animated.timing(opacity, {
          toValue: 0,
          duration: 500,
          useNativeDriver: true,
        }).start(() => {
          setBarcodeBoxes((prev) => prev.filter((x) => x.id !== id));
          setScannedCodes((prev) => {
            const newSet = new Set(prev);
            newSet.delete(data);
            return newSet;
          });
        });
      } else {
        // Save permanent marker for first time detection (for testing)
        if (!permanentMarkers.has(data)) {
          const permanentOpacity = new Animated.Value(1);
          const permanentBox: BarcodeBox = {
            id: `permanent-${data}`,
            data,
            color: "#FFD700", // Gold color for permanent markers
            bounds: c.bounds,
            opacity: permanentOpacity,
          };
          setPermanentMarkers(prev => new Map(prev).set(data, permanentBox));
          
          console.log("[PERMANENT MARKER] First detection saved:", {
            code: data,
            productId,
            bounds: c.bounds,
            pixelPosition: {
              left: Math.round(pxNow.left),
              top: Math.round(pxNow.top),
              width: Math.round(pxNow.width),
              height: Math.round(pxNow.height),
            },
            center: {
              x: Math.round(cx),
              y: Math.round(cy),
            },
          });
        }

        // Log temporary box creation
        console.log("[TEMPORARY BOX] Green box created:", {
          code: data,
          productId,
          bounds: c.bounds,
          pixelPosition: {
            left: Math.round(pxNow.left),
            top: Math.round(pxNow.top),
            width: Math.round(pxNow.width),
            height: Math.round(pxNow.height),
          },
          center: {
            x: Math.round(cx),
            y: Math.round(cy),
          },
          duration: "1.8s (1.2s visible + 0.6s fade)",
        });

        // Green box for success - show longer
        Animated.sequence([
          Animated.delay(1200),
          Animated.timing(opacity, {
            toValue: 0,
            duration: 600,
            useNativeDriver: true,
          }),
        ]).start(() => {
          setBarcodeBoxes((prev) => prev.filter((x) => x.id !== id));
          setScannedCodes((prev) => {
            const newSet = new Set(prev);
            newSet.delete(data);
            return newSet;
          });
        });
      }
    }
  };

  if (hasPermission === null) return <Text>Requesting camera permission…</Text>;
  if (hasPermission === false) return <Text>No access to camera</Text>;

  // Compute viewfinder rect for drawing
  const vfW = camSize.w * VF_WIDTH_RATIO;
  const vfH = camSize.h * VF_HEIGHT_RATIO;
  const vfL = (camSize.w - vfW) / 2;
  const vfT = (camSize.h - vfH) / 2;

  return (
    <View style={styles.container}>
      <View
        style={styles.scannerArea}
        onLayout={(e) => {
          const { width, height } = e.nativeEvent.layout;
          setCamSize({ w: width, h: height });
        }}
      >
        <CameraView
          style={StyleSheet.absoluteFill}
          facing="back"
          barcodeScannerSettings={{ barcodeTypes: ["qr"] }}
          onBarcodeScanned={(event) => handleBarcodes({ barcodes: [event] })}
        />

        <View pointerEvents="none" style={StyleSheet.absoluteFill}>
          <View
            style={{
              position: "absolute",
              top: 0,
              left: 0,
              right: 0,
              height: vfT,
              backgroundColor: "#FFFFFF",
            }}
          />
          {/* Bottom overlay - alt beyaz alan (tamamen opak) */}
          <View
            style={{
              position: "absolute",
              top: vfT + vfH,
              left: 0,
              right: 0,
              bottom: 0,
              backgroundColor: "#FFFFFF",
            }}
          />
          {/* Left overlay - sol beyaz alan (tamamen opak) */}
          <View
            style={{
              position: "absolute",
              top: vfT,
              left: 0,
              width: vfL,
              height: vfH,
              backgroundColor: "#FFFFFF",
            }}
          />
          {/* Right overlay - sağ beyaz alan (tamamen opak) */}
          <View
            style={{
              position: "absolute",
              top: vfT,
              left: vfL + vfW,
              right: 0,
              height: vfH,
              backgroundColor: "#FFFFFF",
            }}
          />
          {/* Yeşil çerçeve - QR okuma alanı + Box container */}
          <View
            style={{
              position: "absolute",
              left: vfL,
              top: vfT,
              width: vfW,
              height: vfH,
              borderRadius: 16,
              borderWidth: 3,
              borderColor: theme.colors.accent,
              backgroundColor: "transparent",
            }}
          >
            {/* Green/Red boxes - Relative to viewfinder */}
            {(() => {
              console.log("[RENDER CYCLE] barcodeBoxes count:", barcodeBoxes.length);
              console.log("[RENDER CYCLE] permanentMarkers count:", permanentMarkers.size);
              return null;
            })()}
            {barcodeBoxes.map((b) => {
              const px = boundsToPixels(
                b.bounds,
                camSize.w || SCREEN_W,
                camSize.h || SCREEN_H
              );
              const isGreen = b.color === theme.colors.accent;
              
              // Viewfinder'a göre relative position
              const relativeLeft = px.left - vfL;
              const relativeTop = px.top - vfT;
              
              console.log(`[RENDER TEMPORARY] ${isGreen ? 'Green' : 'Red'} box:`, {
                id: b.id,
                code: b.data,
                absolute: { left: Math.round(px.left), top: Math.round(px.top) },
                relative: { left: Math.round(relativeLeft), top: Math.round(relativeTop) },
              });

              return (
                <Animated.View
                  key={b.id}
                  style={{
                    position: "absolute",
                    left: relativeLeft,
                    top: relativeTop,
                    width: px.width,
                    height: px.height,
                    borderWidth: 3,
                    borderColor: isGreen ? "#00FF00" : "#FF0000",
                    borderRadius: 8,
                    backgroundColor: isGreen ? "rgba(0, 255, 0, 0.2)" : "rgba(255, 0, 0, 0.2)",
                    opacity: b.opacity,
                    zIndex: 200,
                    elevation: 200, // Android için
                  }}
                />
              );
            })}

            {/* Permanent markers - Relative to viewfinder */}
            {Array.from(permanentMarkers.values()).map((marker) => {
              const px = boundsToPixels(
                marker.bounds,
                camSize.w || SCREEN_W,
                camSize.h || SCREEN_H
              );
              
              const relativeLeft = px.left - vfL;
              const relativeTop = px.top - vfT;
              
              console.log("[RENDER PERMANENT] Gold marker:", {
                id: marker.id,
                code: marker.data,
                absolute: { left: Math.round(px.left), top: Math.round(px.top) },
                relative: { left: Math.round(relativeLeft), top: Math.round(relativeTop) },
              });

              return (
                <View
                  key={marker.id}
                  style={{
                    position: "absolute",
                    left: relativeLeft,
                    top: relativeTop,
                    width: px.width,
                    height: px.height,
                    borderWidth: 3,
                    borderColor: "#FFD700",
                    borderRadius: 8,
                    backgroundColor: "rgba(255, 215, 0, 0.15)",
                    zIndex: 210,
                    elevation: 210, // Android için
                  }}
                >
                  <View
                    style={{
                      position: "absolute",
                      top: -25,
                      left: 0,
                      backgroundColor: "rgba(255, 215, 0, 0.9)",
                      paddingHorizontal: 8,
                      paddingVertical: 4,
                      borderRadius: 4,
                    }}
                  >
                    <Text style={{ color: "#000", fontSize: 11, fontWeight: "bold" }}>
                      {marker.data.split("-")[0]}
                    </Text>
                  </View>
                </View>
              );
            })}
          </View>
        </View>

        {/* Debug info */}
        <View style={styles.debugInfo}>
          <Text style={styles.debugText}>
            Boxes: {barcodeBoxes.length} | Markers: {permanentMarkers.size}
          </Text>
          <Text style={styles.debugText}>
            Cam: {Math.round(camSize.w)}x{Math.round(camSize.h)}
          </Text>
          <TouchableOpacity
            onPress={() => setPermanentMarkers(new Map())}
            style={styles.clearMarkersBtn}
          >
            <Text style={styles.clearMarkersBtnText}>Clear Markers</Text>
          </TouchableOpacity>
        </View>
      </View>

      {/* Scanned Products Section (unchanged) */}
      <View style={styles.bottomPanel}>
        <Text style={styles.title}>Scanned Products</Text>
        <ScrollView style={{ maxHeight: 240 }}>
          {Object.values(products).map((p) => (
            <View key={p.id} style={styles.card}>
              <View>
                <Text style={styles.productName}>{p.id}</Text>
                <Text style={styles.codeCount}>{p.codes.length} pcs</Text>
              </View>
            </View>
          ))}
          {Object.keys(products).length === 0 && (
            <Text style={{ color: theme.colors.subtleText }}>
              No products scanned yet.
            </Text>
          )}
        </ScrollView>

        <TouchableOpacity style={styles.clearButton} onPress={clearAll}>
          <MaterialIcons name="delete-outline" size={20} color="white" />
          <Text style={styles.clearButtonText}>Clear All</Text>
        </TouchableOpacity>
      </View>
    </View>
  );
}

/* ---------- Styles ---------- */
const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: theme.colors.background },
  scannerArea: { flex: 1, backgroundColor: "black" },

  qrBox: {
    position: "absolute",
    borderRadius: 12,
    zIndex: 10,
    justifyContent: "space-between",
    padding: 6,
  },

  rowBetween: {
    flexDirection: "row",
    justifyContent: "space-between",
  },

  corner: {
    width: 12,
    height: 12,
    backgroundColor: "#00FF00",
    borderRadius: 6,
  },

  // Permanent markers (gold boxes)
  permanentMarker: {
    position: "absolute",
    borderWidth: 3,
    borderColor: "#FFD700",
    borderStyle: "dashed",
    borderRadius: 8,
    backgroundColor: "rgba(255, 215, 0, 0.15)",
    zIndex: 5,
  },

  markerLabel: {
    position: "absolute",
    top: -25,
    left: 0,
    backgroundColor: "rgba(255, 215, 0, 0.9)",
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 4,
  },

  markerText: {
    color: "#000",
    fontSize: 11,
    fontWeight: "bold",
  },

  debugInfo: {
    position: "absolute",
    top: 10,
    right: 10,
    backgroundColor: "rgba(0,0,0,0.7)",
    padding: 8,
    borderRadius: 8,
    zIndex: 1000,
  },

  debugText: {
    color: "white",
    fontSize: 12,
    marginBottom: 5,
  },

  clearMarkersBtn: {
    backgroundColor: "#FFD700",
    paddingHorizontal: 10,
    paddingVertical: 5,
    borderRadius: 4,
    alignItems: "center",
  },

  clearMarkersBtnText: {
    color: "#000",
    fontSize: 11,
    fontWeight: "bold",
  },

  bottomPanel: {
    backgroundColor: theme.colors.surface,
    padding: theme.spacing.lg,
    borderTopLeftRadius: theme.radius.lg * 1.5,
    borderTopRightRadius: theme.radius.lg * 1.5,
    shadowColor: "#000",
    shadowOpacity: 0.1,
    shadowRadius: 8,
    elevation: 4,
  },
  title: {
    fontFamily: theme.fonts.bold,
    fontSize: 18,
    color: theme.colors.text,
    marginBottom: theme.spacing.md,
  },
  card: {
    backgroundColor: theme.colors.background,
    borderRadius: theme.radius.md,
    padding: theme.spacing.md,
    marginBottom: theme.spacing.sm,
  },
  productName: {
    fontFamily: theme.fonts.medium,
    fontSize: 16,
    color: theme.colors.text,
  },
  codeCount: {
    color: theme.colors.subtleText,
    fontSize: 13,
  },
  clearButton: {
    marginTop: theme.spacing.lg,
    backgroundColor: theme.colors.danger,
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "center",
    borderRadius: theme.radius.md,
    paddingVertical: 10,
    gap: 8,
  },
  clearButtonText: {
    color: "white",
    fontFamily: theme.fonts.medium,
  },
});
